#!/usr/bin/env node

import { writeFileSync, existsSync } from 'fs'
import { resolve, dirname } from 'path'
import { fileURLToPath } from 'url'
import process from 'process'

async function loadDotenv() {
  try {
    const { config } = await import('dotenv')
    const cwd = process.cwd()
    const candidateFiles = [
      '.env.local',
      '.env.development',
      '.env'
    ]

    for (const file of candidateFiles) {
      const fullPath = resolve(cwd, file)
      if (existsSync(fullPath)) {
        config({ path: fullPath, override: false })
      }
    }
  } catch (error) {
    // Dotenv is optional. Continue if not installed.
    if (error.code !== 'ERR_MODULE_NOT_FOUND') {
      console.warn('[generate-sitemap] Dotenv load warning:', error)
    }
  }
}

function ensureEnvironment(variableName) {
  const value = process.env[variableName]
  if (!value) {
    throw new Error(`Environment variable ${variableName} is required to generate the sitemap.`)
  }
  return value
}

function formatDate(dateLike) {
  if (!dateLike) {
    return new Date().toISOString().split('T')[0]
  }

  const date = new Date(dateLike)
  if (Number.isNaN(date.getTime())) {
    return new Date().toISOString().split('T')[0]
  }

  return date.toISOString().split('T')[0]
}

function buildUrlEntry({ loc, lastmod, changefreq, priority }) {
  return `  <url>\n    <loc>${loc}</loc>\n    <lastmod>${lastmod}</lastmod>\n    <changefreq>${changefreq}</changefreq>\n    <priority>${priority}</priority>\n  </url>`
}

async function fetchPublishedPosts({ supabaseUrl, supabaseKey }) {
  const { createClient } = await import('@supabase/supabase-js')

  const supabase = createClient(supabaseUrl, supabaseKey, {
    auth: { persistSession: false }
  })

  const { data, error } = await supabase
    .from('blog_posts')
    .select('slug, updated_at, published_at, status')
    .eq('status', 'published')

  if (error) {
    throw new Error(`Supabase fetch failed: ${error.message}`)
  }

  return (data ?? [])
    .filter(post => Boolean(post.slug))
    .map(post => ({
      loc: `/blog/${post.slug}`,
      lastmod: formatDate(post.updated_at ?? post.published_at),
      changefreq: 'monthly',
      priority: '0.8'
    }))
}

async function main() {
  await loadDotenv()

  const baseUrl = process.env.SITEMAP_BASE_URL ?? 'https://studio.teknolojimenajeri.com'
  const supabaseUrl = ensureEnvironment('VITE_SUPABASE_URL')
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SERVICE_ROLE || process.env.VITE_SUPABASE_ANON_KEY

  if (!supabaseKey) {
    throw new Error('One of SUPABASE_SERVICE_ROLE_KEY, SUPABASE_SERVICE_ROLE or VITE_SUPABASE_ANON_KEY must be provided to generate the sitemap.')
  }

  const staticRoutes = [
    { loc: '/', changefreq: 'weekly', priority: '1.0' },
    { loc: '/blog', changefreq: 'daily', priority: '0.9' },
    { loc: '/gallery', changefreq: 'monthly', priority: '0.6' },
    { loc: '/more', changefreq: 'monthly', priority: '0.5' },
    { loc: '/unsubscribe', changefreq: 'monthly', priority: '0.3' }
  ].map(route => ({
    loc: `${baseUrl}${route.loc}`,
    lastmod: formatDate(new Date()),
    changefreq: route.changefreq,
    priority: route.priority
  }))

  const dynamicRoutes = await fetchPublishedPosts({ supabaseUrl, supabaseKey })
  const fullyQualifiedDynamicRoutes = dynamicRoutes.map(route => ({
    ...route,
    loc: `${baseUrl}${route.loc}`
  }))

  const urlEntries = [...staticRoutes, ...fullyQualifiedDynamicRoutes]
    .map(buildUrlEntry)
    .join('\n\n')

  const xml = `<?xml version="1.0" encoding="UTF-8"?>\n<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"\n        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n        xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9\n        http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd">\n  <!-- Generated by scripts/generate-sitemap.mjs -->\n\n${urlEntries}\n\n</urlset>\n`

  const __filename = fileURLToPath(import.meta.url)
  const __dirname = dirname(__filename)
  const outputPath = resolve(__dirname, '..', 'public', 'sitemap.xml')

  writeFileSync(outputPath, xml, 'utf-8')
  console.log(`[generate-sitemap] Updated sitemap with ${urlEntries.split('<url>').length - 1} entries.`)
}

main().catch(error => {
  console.error('[generate-sitemap] Failed to generate sitemap.')
  console.error(error)
  process.exitCode = 1
})

